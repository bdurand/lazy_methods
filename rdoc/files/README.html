<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>File: README</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



  <div id="fileHeader">
    <h1>README</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>README
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Tue Jun 19 22:32:28 -0500 2007</td>
    </tr>
    </table>
  </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <h2><a href="../classes/LazyMethods.html">LazyMethods</a></h2>
<p>
So your Rails application is successful beyond your wildest dreams and now
your meager servers are straining under the load. You figure you&#8216;ll
add some caching to your views and all will be well again. Unfortunately,
your controller actions load up all sorts of instance variables with
records from the database. The caching won&#8216;t do you much good if your
database is still getting slammed. You could move your query logic to the
views behind the caching layer, but that just feels icky. Besides, that
will break all your tests and you really don&#8216;t feel like fixing them.
</p>
<h2>Enter <a href="../classes/LazyMethods.html">LazyMethods</a>.</h2>
<p>
This plugin adds a virtual lazy version of every method on every class.
Lazy methods have the same name as the original method name but prefixed
with &quot;lazy_&quot;. A lazy method will return a proxy object that looks
and acts just like the result from calling the actual method. The trick is
that the actual method will not be called until a method is invoked on the
proxy object. This way you can continue to set up the business logic in
your controller and have it only actually executed only as needed.
</p>
<p>
If you add fragment caching to your views and the cache returns a value and
bypasses your view code, the method will never be invoked. Thanks to the
magic of Ruby the proxy object will even act like the class it is proxying
in class to class and kind_of?
</p>
<p>
A simple example:
</p>
<p>
The normal way to do it (at least according to every tutorial):
</p>
<p>
def index
</p>
<pre>
        @records = MyRecord.find(:all, :conditions =&gt; {:name =&gt; params[:name]})
</pre>
<p>
end
</p>
<p>
And in the view:
</p>
<p>
&lt;% cache(params[:names]) -%&gt;
</p>
<pre>
        &lt;% @records.each do |record| -%&gt;
                &lt;div&gt;&lt;%=record.title%&gt;&lt;/div&gt;
        &lt;% end -%&gt;
</pre>
<p>
&lt;% end -%&gt;
</p>
<p>
Now even if you cache the fragments in your view that use @records, the
database will still be hit to select and instantiate all the records. You
could remove the code from the action and simple add it back into the view.
However, this just feels wrong and is inherently harder to test. Instead
just use a lazy method.
</p>
<p>
def index
</p>
<pre>
        @records = MyRecord.lazy_find(:all, :conditions =&gt; {:name =&gt; params[:name]})
</pre>
<p>
end
</p>
<p>
Now, as long as no methods are invoked on @records, the original find
method will never be called. As soon as the first method is called, the
original find method will be called. It will never be called more than
once. You can even pass in a block to the lazy method.
</p>
<h2>Testing</h2>
<p>
Since the proxy object looks and acts just like the real result object, all
your view tests should still pass. Your controller tests should pass will
little or no tweaking.
</p>

    </div>


   </div>


  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>